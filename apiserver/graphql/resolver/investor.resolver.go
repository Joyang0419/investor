package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	graphql1 "apiserver/graphql"
	"apiserver/graphql/model"
	"definition/response"
	"protos/micro_auth"
	"tools/errorx"
	"tools/logger"
	"tools/slicex"
)

// CreateInvestor is the resolver for the createInvestor field.
func (r *mutationResolver) CreateInvestor(ctx context.Context, input model.CreateInvestorInput) (*model.CreateInvestorPayload, error) {
	conn, err := r.GrpcConnectionPools.MicroAuthGrpcConnPool.GetConnFromPool()
	if errorx.CheckErrorExist(err) {
		logger.Error("[Investors]r.GrpcConnectionPools.MicroAuthGrpcConnPool.GetConnFromPool err: %v", err)
		return &model.CreateInvestorPayload{
			CustomCode: response.ServerInternalError,
		}, nil
	}
	defer func() {
		r.GrpcConnectionPools.MicroAuthGrpcConnPool.ReturnConnectionToPool(conn)
	}()

	service := micro_auth.NewInvestorServiceClient(
		conn,
	)
	investor, err := service.CreateInvestor(
		ctx,
		&micro_auth.CreateInvestorInput{
			Username: input.Username,
			Password: input.Password,
		},
	)
	if errorx.CheckErrorExist(err) {
		st, ok := status.FromError(err)
		if !ok {
			return &model.CreateInvestorPayload{
				CustomCode: response.ServerInternalError,
			}, nil
		}
		if st.Code() == codes.AlreadyExists {
			return &model.CreateInvestorPayload{
				CustomCode: response.ClientConflict,
			}, nil
		}
		return &model.CreateInvestorPayload{
			CustomCode: response.ServerInternalError,
		}, nil
	}

	return &model.CreateInvestorPayload{
		Investor: &model.Investor{
			ID:       investor.Id,
			Username: investor.Username,
			Password: investor.Password,
		},
		CustomCode: response.Success,
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (string, error) {
	panic(fmt.Errorf("not implemented: Login - login"))
}

// Investors is the resolver for the Investors field.
func (r *queryResolver) Investors(ctx context.Context, input model.QueryInvestorsInput) ([]*model.Investor, error) {
	conn, err := r.GrpcConnectionPools.MicroAuthGrpcConnPool.GetConnFromPool()
	if errorx.CheckErrorExist(err) {
		return nil, fmt.Errorf("[Investors]r.GrpcConnectionPools.MicroAuthGrpcConnPool.GetConnFromPool err: %w", err)
	}
	service := micro_auth.NewInvestorServiceClient(
		conn,
	)
	grpcResponse, err := service.GetInvestors(
		ctx,
		&micro_auth.QueryInvestorsParams{
			Id:       input.Ids,
			Username: input.Usernames,
			PageSize: uint32(input.PageSize),
			Page:     uint32(input.Page),
		},
	)
	if errorx.CheckErrorExist(err) {
		return nil, fmt.Errorf("[Investors]service.GetInvestors err: %w", err)
	}

	gqlInvestors := make([]*model.Investor, 0, slicex.GetLength(grpcResponse.Investors))
	for idx := range grpcResponse.Investors {
		gqlInvestors = append(gqlInvestors,
			&model.Investor{
				ID:       grpcResponse.Investors[idx].Id,
				Username: grpcResponse.Investors[idx].Username,
				Password: grpcResponse.Investors[idx].Password,
			},
		)
	}

	return gqlInvestors, nil
}

// Mutation returns graphql1.MutationResolver implementation.
func (r *Resolver) Mutation() graphql1.MutationResolver {
	return &mutationResolver{
		Resolver:            r,
		GrpcConnectionPools: r.GrpcConnectionPools,
	}
}

// Query returns graphql1.QueryResolver implementation.
func (r *Resolver) Query() graphql1.QueryResolver {
	return &queryResolver{
		Resolver:            r,
		GrpcConnectionPools: r.GrpcConnectionPools,
	}
}

type mutationResolver struct {
	GrpcConnectionPools *GrpcConnectionPools
	*Resolver
}
type queryResolver struct {
	GrpcConnectionPools *GrpcConnectionPools
	*Resolver
}
