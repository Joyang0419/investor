package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	graphql1 "apiserver/graphql"
	"apiserver/graphql/model"
	"definition/response"
	"protos/micro_auth"
	"tools/errorx"
	"tools/logger"
	"tools/slicex"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

// CreateInvestor is the resolver for the createInvestor field.
func (r *mutationResolver) CreateInvestor(ctx context.Context, input model.CreateInvestorInput) (*model.CreateInvestorPayload, error) {
	// TODO GRPC 封裝, Conn, Close
	// TODO grpcConn 可以重複使用，所以應該用Dependency Injection 注入到Resolver, 先這樣，串起來後再改。
	grpcConn, err := grpc.DialContext(
		ctx,
		"localhost:50052",
		// TODO meaning 是什麼意思, Block 是等到Grpc 連線成功才返回, WithWithTransportCredentials ???
		grpc.WithTransportCredentials(insecure.NewCredentials()),
		grpc.WithBlock(),
	)
	if err != nil {
		return nil, fmt.Errorf("[CreateInvestor]grpc.Dial err: %w", err)
	}
	defer func(grpcConn *grpc.ClientConn) {
		if errClose := grpcConn.Close(); errClose != nil {
			logger.Error("[CreateInvestor]grpcConn.Close err: %v", errClose)
		}
	}(grpcConn)

	investor, err := micro_auth.NewInvestorServiceClient(grpcConn).CreateInvestor(
		ctx,
		&micro_auth.CreateInvestorInput{
			Username: input.Username,
			Password: input.Password,
		},
	)
	if err != nil {
		// TODO GRPC err 不能用golang errorIs 處理啊
		//if errors.Is(err, error2.MicroErrOperationConflict) {
		//	return &model.CreateInvestorPayload{
		//		CustomCode: response.ClientConflict,
		//	}, nil
		//}
		//return &model.CreateInvestorPayload{
		//	CustomCode: response.ServerInternalError,
		//}, nil

		// TODO 封裝 把 err 丟進去 還出來 CustomCode
		st, ok := status.FromError(err)
		if !ok {
			return &model.CreateInvestorPayload{
				CustomCode: response.ServerInternalError,
			}, nil
		}
		// 檢查是否為操作衝突錯誤
		if st.Code() == codes.AlreadyExists {
			return &model.CreateInvestorPayload{
				CustomCode: response.ClientConflict,
			}, nil
		}
	}

	return &model.CreateInvestorPayload{
		Investor: &model.Investor{
			ID:       investor.Id,
			Username: investor.Username,
			Password: investor.Password,
		},
		CustomCode: response.Success,
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (string, error) {
	panic(fmt.Errorf("not implemented: Login - login"))
}

// Investors is the resolver for the Investors field.
func (r *queryResolver) Investors(ctx context.Context, input model.QueryInvestorsInput) ([]*model.Investor, error) {
	// TODO independcy injection groc conn
	// TODO GRPC 封裝, Conn, Close
	// TODO grpcConn 可以重複使用，所以應該用Dependcy Injection 注入到Resolver, 先這樣，串起來後再改。
	grpcConn, err := grpc.DialContext(
		ctx,
		"localhost:50052",
		// TODO meaning 是什麼意思, Block 是等到Grpc 連線成功才返回, WithWithTransportCredentials ???
		grpc.WithTransportCredentials(insecure.NewCredentials()),
		grpc.WithBlock(),
	)
	// TODO grpc connect Err 定義
	if err != nil {
		return nil, fmt.Errorf("[CreateInvestor]grpc.Dial err: %w", err)
	}
	defer func(grpcConn *grpc.ClientConn) {
		if errClose := grpcConn.Close(); errClose != nil {
			logger.Error("[CreateInvestor]grpcConn.Close err: %v", errClose)
		}
	}(grpcConn)

	service := micro_auth.NewInvestorServiceClient(grpcConn)
	grpcResponse, err := service.GetInvestors(
		ctx,
		&micro_auth.QueryInvestorsParams{
			Id:       input.Ids,
			Username: input.Usernames,
			PageSize: uint32(input.PageSize),
			Page:     uint32(input.Page),
		},
	)
	if errorx.CheckErrorExist(err) {
		return nil, fmt.Errorf("[Investors]service.GetInvestors err: %w", err)
	}

	// TODO 這邊想一下，目前遇到的困難是 Grpc 的 Response 與 GQL 的 Response 不一樣，所以要轉換,
	// TODO 要做到 GRPC response, 就是這個api 的 Response,
	gqlInvestors := make([]*model.Investor, 0, slicex.GetLength(grpcResponse.Investors))
	for idx := range grpcResponse.Investors {
		gqlInvestors = append(gqlInvestors,
			&model.Investor{
				ID:       grpcResponse.Investors[idx].Id,
				Username: grpcResponse.Investors[idx].Username,
				Password: grpcResponse.Investors[idx].Password,
			},
		)
	}

	return gqlInvestors, nil
}

// Mutation returns graphql1.MutationResolver implementation.
func (r *Resolver) Mutation() graphql1.MutationResolver { return &mutationResolver{r} }

// Query returns graphql1.QueryResolver implementation.
func (r *Resolver) Query() graphql1.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
