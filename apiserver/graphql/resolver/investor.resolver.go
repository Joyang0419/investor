package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"

	graphql1 "apiserver/graphql"
	"apiserver/graphql/model"
	"protos/micro_auth"
	"tools/errorx"
	"tools/logger"
	"tools/slicex"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

// CreateInvestor is the resolver for the createInvestor field.
func (r *mutationResolver) CreateInvestor(ctx context.Context, input model.CreateInvestorInput) (*model.Investor, error) {
	// TODO independcy injection groc conn
	// TODO GRPC 封裝, Conn, Close
	// TODO grpcConn 可以重複使用，所以應該用Dependcy Injection 注入到Resolver, 先這樣，串起來後再改。
	grpcConn, err := grpc.DialContext(
		ctx,
		"localhost:50052",
		// TODO meaning 是什麼意思, Block 是等到Grpc 連線成功才返回, WithWithTransportCredentials ???
		grpc.WithTransportCredentials(insecure.NewCredentials()),
		grpc.WithBlock(),
	)
	if err != nil {
		return nil, fmt.Errorf("[CreateInvestor]grpc.Dial err: %w", err)
	}
	defer func(grpcConn *grpc.ClientConn) {
		if errClose := grpcConn.Close(); errClose != nil {
			logger.Error("[CreateInvestor]grpcConn.Close err: %v", errClose)
		}
	}(grpcConn)
	investor, err := micro_auth.NewInvestorServiceClient(grpcConn).CreateInvestor(
		ctx,
		&micro_auth.CreateInvestorInput{
			LoginAccount: input.LoginAccount,
			Password:     input.Password,
		},
	)
	if err != nil {
		return nil, fmt.Errorf("[CreateInvestor]CreateInvestor err: %w", err)
	}
	return &model.Investor{
		// TODO 實現 GQL 支援 INT64
		InvestorID:   investor.InvestorID,
		LoginAccount: investor.LoginAccount,
		Password:     investor.Password,
	}, nil
}

// Investors is the resolver for the Investors field.
func (r *queryResolver) Investors(ctx context.Context, queryParams model.QueryInvestorsParams) ([]*model.Investor, error) {
	// TODO independcy injection groc conn
	// TODO GRPC 封裝, Conn, Close
	// TODO grpcConn 可以重複使用，所以應該用Dependcy Injection 注入到Resolver, 先這樣，串起來後再改。
	grpcConn, err := grpc.DialContext(
		ctx,
		"localhost:50052",
		// TODO meaning 是什麼意思, Block 是等到Grpc 連線成功才返回, WithWithTransportCredentials ???
		grpc.WithTransportCredentials(insecure.NewCredentials()),
		grpc.WithBlock(),
	)
	if err != nil {
		return nil, fmt.Errorf("[CreateInvestor]grpc.Dial err: %w", err)
	}
	defer func(grpcConn *grpc.ClientConn) {
		if errClose := grpcConn.Close(); errClose != nil {
			logger.Error("[CreateInvestor]grpcConn.Close err: %v", errClose)
		}
	}(grpcConn)

	service := micro_auth.NewInvestorServiceClient(grpcConn)
	grpcResponse, err := service.GetInvestors(
		ctx,
		&micro_auth.QueryInvestorsParams{
			InvestorIDs:   queryParams.InvestorIDs,
			LoginAccounts: queryParams.LoginAccounts,
			PageSize:      uint32(queryParams.PageSize),
			Page:          uint32(queryParams.Page),
		},
	)
	if errorx.CheckErrorExist(err) {
		return nil, fmt.Errorf("[Investors]service.GetInvestors err: %w", err)
	}

	// TODO 這邊想一下，目前遇到的困難是 Grpc 的 Response 與 GQL 的 Response 不一樣，所以要轉換,
	// TODO 要做到 GRPC response, 就是這個api 的 Response,
	gqlInvestors := make([]*model.Investor, 0, slicex.GetLength(grpcResponse.Investors))
	for idx := range grpcResponse.Investors {
		gqlInvestors = append(gqlInvestors,
			&model.Investor{
				InvestorID:   grpcResponse.Investors[idx].InvestorID,
				LoginAccount: grpcResponse.Investors[idx].LoginAccount,
				Password:     grpcResponse.Investors[idx].Password,
			},
		)
	}

	return gqlInvestors, nil
}

// Mutation returns graphql1.MutationResolver implementation.
func (r *Resolver) Mutation() graphql1.MutationResolver { return &mutationResolver{r} }

// Query returns graphql1.QueryResolver implementation.
func (r *Resolver) Query() graphql1.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
